<!doctype html><html><head><meta charset="utf-8"/><title>San-SSR</title><link rel="icon" href="/san-ssr/favicon.ico"><script>window['SAN_DOCIT'] = {};</script><base href="/san-ssr/"><meta name="description" content="San-SSR 文档"><link href="/san-ssr/static/css/chunk-vendors.css" rel="stylesheet"></head><body><div id="app"><div id="site"><header id="header"><a href="/san-ssr/" class="navbar"><img src="/san-ssr/logo.svg" alt="Home" class="logo"> <span>San-SSR</span></a><ul><li><a target="_blank" href="https://github.com/baidu/san-ssr">GitHub</a></li></ul></header><aside id="sidebar" class="sidebar"><ul class="tree"><li><span>Documentation</span><ul><li data-id="/"><a href="/san-ssr/" onclick="return false;">介绍</a></li><li data-id="/documentation/quick-start/"><a href="/san-ssr/documentation/quick-start/" onclick="return false;">快速开始</a></li><li data-id="/documentation/precompile/"><a href="/san-ssr/documentation/precompile/" onclick="return false;">预编译组件代码</a></li><li data-id="/documentation/types-of-input/"><a href="/san-ssr/documentation/types-of-input/" onclick="return false;">支持的三种输入方式及区别</a></li><li data-id="/documentation/lifecycle/"><a href="/san-ssr/documentation/lifecycle/" onclick="return false;">生命周期、属性及方法</a></li><li data-id="/documentation/ways-to-write-components/"><a href="/san-ssr/documentation/ways-to-write-components/" onclick="return false;">组件的两种写法</a></li></ul></li><li><span>Guide</span><ul><li data-id="/guide/use-san-store/"><a href="/san-ssr/guide/use-san-store/" onclick="return false;">使用 San-Store</a></li><li data-id="/guide/use-san-composition/"><a href="/san-ssr/guide/use-san-composition/" onclick="return false;">使用 San-Composition</a></li><li data-id="/guide/custom-output-data/"><a href="/san-ssr/guide/custom-output-data/" onclick="return false;">自定义数据输出</a></li><li data-id="/guide/custom-components-path/"><a href="/san-ssr/guide/custom-components-path/" onclick="return false;">渲染阶段自定义组件路径</a></li><li data-id="/guide/use-outside-component/"><a href="/san-ssr/guide/use-outside-component/" onclick="return false;">手动传入组件类进行-render</a></li><li data-id="/guide/mark-external-component/"><a href="/san-ssr/guide/mark-external-component/" onclick="return false;">使用-markExternalComponent-特性进行编译</a></li></ul></li><li><span>Under the hood</span><ul><li data-id="/under-the-hood/how-san-ssr-use-component-class/"><a href="/san-ssr/under-the-hood/how-san-ssr-use-component-class/" onclick="return false;">San-SSR 是如何使用组件类的</a></li></ul></li></ul></aside><article id="content"><div id="router-view" class="router-view"><div class="content markdown-content"><div class="markdown"><h1 id="san-ssr-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E7%B1%BB%E7%9A%84">San-SSR 是如何使用组件类的</h1><p>San-SSR 在执行过程中会在编译和渲染两个阶段都用到组件类。</p><h2 id="%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">编译阶段</h2><p>在编译阶段，San-SSR 需要获取组件类上的 template、components、initData 等属性。</p><p>此时，San-SSR 不会去尝试创建组件类实例，当输入为文件路径时，会通过静态分析的方式来获取这些属性。</p><p>而当输入为组件类时，则需要从组件类上直接获取，因此这些属性需要能直接从组件类上读取到。</p><ul><li>对于使用 <code>const MyComponent = san.defineComponent</code> 定义的组件，San-SSR 会尝试从 <code>MyComponent.prototype</code> 上读取这些属性。</li><li>对于使用 <code>MyComponent extends san.Component</code> 定义的组件，San-SSR 会尝试从 <code>MyComponent</code> 上直接读取这些属性。这也是为什么这些属性需要<a href="/pages/Documentation/ways-to-write-components.html">使用 static 来定义</a>。</li></ul><h2 id="%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5">渲染阶段</h2><p>在渲染阶段，San-SSR 会通过 new 的形式创建组件实例，但<strong>该实例仅会被创建一次</strong>，所有的 render 过程中用到的实例，都是通过 Object.create 创建出来的。</p><p>所以组件中的方法有一下注意事项：</p><ol><li>可以在 this 上添加属性，不会影响二次渲染。</li><li>不可以修改 this 上<a href="/pages/Documentation/lifecycle.html#%E5%B1%9E%E6%80%A7">会被 San-SSR 用到的属性</a>，因为该操作会修改唯一的组件实例，该修改会保留，影响后续的渲染过程。</li></ol></div></div></div><aside class="toc"><ul class="tree"></ul></aside></article></div></div><script src="/san-ssr/static/js/chunk-vendors.js"></script><script src="/san-ssr/static/js/client-entry.js"></script></body></html>